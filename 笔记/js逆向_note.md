## 内容:

- 为什么要进行JavaScript加密或混淆？
- JavaScript代码加密的实现；
- JavaScript代码混淆技术介绍；
- JavaScript代码混淆工具介绍；
- JavaScript代码混淆实现方案及原理；



为什么要进行JavaScript加密或混淆？

- JavaScript代码运行于客户端；
- JavaScript代码是公开透明的；



如何对JavaScript代码进行保护？

- 代码压缩：去除空格、换行等；
- 代码加密：eval、emscripten、WebAssembly等；
- 代码混淆：变量混淆、常量混淆、控制流扁平化、调试保护等；



JavaScript加密实现：

- eval加密
- Emscripten
- WebAssembly



JavaScript混淆技术：

- 变量混淆
- 反调试
- 字符串混淆
- 多态变异
- 属性加密
- 锁定域名
- 属性加密
- 锁定域名
- 控制流平坦化
- 反格式化
- 僵尸代码注入
- 特殊编码
- 代码压缩



JavaScript混淆实现：

- 基于javascript-obfuscator
- 多种混淆支持
- 依赖于Node.js



加密分析流程总结：

1、查看关键包-分析哪些参数是加密的；

2.0 搜索参数

​		参数名 = /参数名 = / 参数名：/ 参数名：

​		参数名

2.1 查看网络面板的initiator（发起)

2.2 XHR断点调试；

2.3 hook相关逻辑；

3.分析加密；

4.补全加密逻辑；

---

将JavaScript代码转化成颜文字网络表情的编码以达到混淆的目的 

原理：这类混淆通常都是使用构造函数将字符串作为代码运行

例如：const sum = new Function('a','b','return a+b');

​			console.log(sum(2,6));

解决方法：

​			1、直接将混淆后的代码粘贴至控制台通过VM查看源代码；

​			2、删除代码末尾的"('_');"，替换为"toString()"或将修改后的代码粘贴至控制台运行。

---

将JavaScript代码转换仅由符号组成的代码以达到混淆的目的

原理 ：这类混淆通常都是使用构造函数将字符串作为代码运行

转换流程大致如下：

Function('alert(1)')()

(0)["constructor"]["constructor"]("alert(1)")();

$ = "constructor";

$$ = "alert(1)";

$_ = ~[]; //0按位取反就是-1

($_)[$][$]($$)();

解决方法：

​	1、直接将混淆的代码粘贴至控制台通过VM查看源代码；

​	2、删除与代码结尾的"()"替换为"toString()"或将修改后的代码粘贴至控制台运行；

---

样例四其实谈不上加密 ，只能算是一种编码(Encode)或者也可以称为是一种打包(packer)，类似于base64这样的编码，都是可以以一定方式还原的。

可以看到这个样例的开头是eval，在js中eval中接受的参数是包含有效JavaScript代码的字符串。

这个字符串将由JavaScript分析器进行分析和执行。所以我们可以断定Function(p,a,c,k,e,r)或者是function(p,a,c,k,e,d)返回的就是解密好的js源代码，然后传递给eval。

所以我们只需要将eval更改为alert/document.write/console.log即可解密。

---

样例五总结

样例五可以说是一类混淆程度较为严重的例子。

通过将原始的js代码经过一系列的标识符混淆、死代码注入、防调试注入等操作达到代码保护的目的。

这类代码通过调试还原也可以达到破解的目的，但是会耗费大量的精力。

我们面对这类混淆的解决方法：

0、熟悉这类混淆通用的混淆代码；

1、找到代码的入口；

2、将代码主体扣取出来；

3、去除无用的代码与环境监测代码（埋雷），补全缺失的代码；

4、运行处理后的代码；

CryptoJS is not defined

var CryptoJS = require("crypto-js")

----

对称加密算法：

什么是对称加密呢？你可以这么理解，一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。

---

非对称加密算法：

- A要向B发送信息 ，A和B都要产生一对用于加密和解密的公钥和私钥。
- A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。
- A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。
- A将这个消息发送给B(已经用B的公钥加密信息)。
- B收到这个消息后，B用自己的私钥解密A的消息，其他所有收到这个报文的人都无法解密 ，因为只有B才有B的私钥。
- 反过来，B给A发送消息也是一样。

---

对称加密算法和非对称加密算法区别：

- 对称加密的加密和解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络中传输，所以安全性不高。
- 非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。
- 解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。

---

AES加密是什么？？

AES算法全称为Advanced Encryption Standard，是DES算法的替代者，也是现在最流行的对称加密算法之一。

AES加密三要素：

想要搞明白AES算法，首先要搞清楚三个基本概念。密钥、填充、模式。

AES加密三要素 - 密钥

对称加密之所以对称就是因为这类算法对明文的加密和解密使用的是同一个密钥。

AES支持三种长度的密钥：128位、192位、256位。

AES加密三要素 - 填充

说到填充一定要说一下，AES分组加密的特性，AES加密并不是一股脑将明文加密成密文的，而是把明文拆分成一个一个独立的明文块，且每个明文块128bit。

假如一段明文长度是196bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时候怎么办呢？就需要对明文块进行填充(Padding)。

---

AES加密三要素 - 填充种类

- NoPadding
- PKCS7Padding
- ZeroPadding
- AnsiX923
- Iso10126
- Iso97971

---

AES加密三要素 - ECB工作模式

ECB模式(Electronic Codebook Book)是最简单的工作模式，在该模式下，每一个明文块的加密都是完全独立，互不干涉的。

这样的好处是什么呢？

1、简单 

2、有利于并行计算

缺点同样也很明显：

相同的明文块经过加密会变成相同的密文块，因此安全性较差。

---

AES加密三要素 - CBC模式

CBC模式（Cipher Block Chaining）引入了一个新的概念：初始向量IV（Initialization vector）。

IV是做什么用的呢？它的作用和MD5的“加盐”有些类似，目的是防止同样的明文块始终加密成同样的密文块。

CBC模式在每一个明文块加密前会让明文块和一个值先做异或操作。

IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它前一个明文块所加密出的密文块相异或。

这样相同的明文块加密出的密文块显然是不一样的。

CBC模式的好处是什么呢？安全性更高。

坏处也很明显 ：

1、无法并行计算，性能上不如ECB；

2、引入初始化向量IV，增加复杂度；

---

AES加密流程总结：

1、把明文按照128bit拆分成若干个明文块。

2、按照选择的填充方式来填充最后一个明文块。

3、每一个明文块利用AES加密器和密钥，加密成密文块。

4、拼接所有的密文块，成为最终的密文结果。

---

AES加密流程_Python实现流程：

加密：

- 确定初始向量vi
- 用户数据字符串数据转化为字节串(utf8)
- 用户数据字节串数据进行补位(pad)
- 根据密钥、AES模式、初始向量，实例化AES加密器，其中密钥、初始向量需要进行字节串转化(utf8)
- 使用AES加密器，对处理过后的用户数据进行加密
- 将加密后的数据使用Base64进行编码，返回byte字节串
- 将加密数据byte字节串按utf-8进行字符串解码
- 得到加密数据

解密：

- 确定初始向量vi(通常和加密时的一样)
- 对加密后的数据进行utf8编码
- 将编码后的数据进行Base64解码
- 根据密钥、AES模式、初始向量，实例化AES加密器，其中密钥、初始向量需要进行字节串转化(utf8)
- 使用AES加密器，对处理过后的用户数据进行解密
- 对解密后的用户数据进行去补位(unpad)
- 将去补位后的数据进行utf8解码
- 得到解密数据







